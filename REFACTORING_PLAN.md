# Refactoring Plan for src/main.rs Input Handling

This document outlines the plan to refactor the input handling logic in `src/main.rs` to introduce more abstraction, support stdin, defer data loading, and remove the prompt requirement for stdin.

**1. Introduce `InputSource` Enum:**
Define a new enum `InputSource` to represent the origin and type of the input, decoupling it from the actual data initially.

```rust
#[derive(Debug, Clone)]
enum InputSource {
    Url(Url), // Represents a URL to be fetched
    File(PathBuf), // Represents a file path to be read
    Stdin, // Represents input from standard input
    RawData { identifier: String, mime_type: mime::Mime, data: Vec<u8> }, // Represents data already loaded (e.g., split PDF pages)
}
```

**2. Update `InputUnit` Struct:**
Modify the `InputUnit` struct to use the new `InputSource` enum, removing the direct `data` and `mime_type` fields. The `identifier` will remain crucial.

```rust
#[derive(Debug, Clone)]
struct InputUnit {
    identifier: String, // Unique identifier (e.g., filename, URL, "stdin", "filename.pdf page 1/10")
    source: InputSource,
}
```

**3. Refactor Input Gathering Functions:**
Adjust the functions responsible for identifying inputs to create `InputUnit`s with the appropriate `InputSource`, deferring data loading:

*   **`fetch_url_input`:** Will return `Result<Option<InputUnit>>` containing `InputSource::Url(url)`. It will *not* fetch the URL content at this stage.
*   **`split_pdf_lopdf`:** Will change signature to `fn split_pdf_lopdf(path: &PathBuf, identifier_base: &str) -> Result<Vec<InputUnit>>`. It will read the PDF file specified by `path`, split it into pages, and return a `Vec<InputUnit>`, where each unit has `source: InputSource::RawData { ... }` containing the actual page data, PDF mime type, and a specific page identifier.
*   **`process_file_input`:**
    *   If `split_pdf` is true and the file is a PDF, it will call the modified `split_pdf_lopdf` to get `Vec<InputUnit>` containing raw page data.
    *   Otherwise, it will return a `Vec` containing a single `InputUnit` with `source: InputSource::File(path)`. It will *not* read the file content at this stage.
*   **`process_input_string`:** Will be updated to call the modified `fetch_url_input` or `process_file_input`.
*   **`gather_input_units`:** Will collect the `InputUnit`s generated by `process_input_string`.

**4. Implement Stdin Handling:**
Modify the `main` function:

*   Check if `args.inputs` is empty.
*   If it is empty, create a `Vec<InputUnit>` containing a single `InputUnit` with `identifier: "stdin".to_string()` and `source: InputSource::Stdin`.

**5. Remove Prompt Requirement Check:**
Remove the logic around lines 400-403 in `main` that previously enforced the `--prompt` and `--model` requirement when `args.inputs` was empty.

**6. Defer Data Loading to Processing Loop:**
Modify the main concurrent processing loop (`tokio::spawn` block inside `processing_stream`):

*   Receive the `WorkItem::ProcessInput(unit)`.
*   Inside the task, before calling the API or preparing output, match on `unit.source`:
    *   `InputSource::Url(url)`: Fetch the URL content and determine the mime type *here*.
    *   `InputSource::File(path)`: Read the file content and guess the mime type *here*.
    *   `InputSource::Stdin`: Read content from stdin and determine the mime type (e.g., default to `text/plain`) *here*. Use `tokio::io::stdin()` and `read_to_end()`. Consider concurrency implications.
    *   `InputSource::RawData { mime_type, data, .. }`: Use the provided `data` and `mime_type` directly.
*   Store the loaded `data` and `mime_type` in local variables within the task.
*   Handle potential errors during data loading (fetch/read failures).

**7. Update API Call/Output Logic:**
Use the `data` and `mime_type` loaded in the previous step to:

*   Construct the `GenerateContentRequest` if a model is specified.
*   Handle the no-model case (outputting text content directly, returning an error for binary data).

**8. Update Tests:**
Review and update the existing tests in `tests/` to reflect the changes. Add new tests specifically for the stdin pathway and deferred loading.

**Visual Plan (Mermaid Diagram):**

```mermaid
graph LR
    A[Start] --> B{Inputs Provided?};
    B -- Yes --> C[gather_input_units];
    B -- No --> D[Create Stdin InputUnit];
    C --> E[Create WorkItems];
    D --> E;
    E --> F[Processing Loop (buffer_unordered)];
    F --> G{Process WorkItem};
    G -- InputUnit --> H{Match unit.source};
    H -- Url --> I[Fetch URL Data & Mime];
    H -- File --> J[Read File Data & Mime];
    H -- Stdin --> K[Read Stdin Data & Mime];
    H -- RawData --> L[Use Existing Data & Mime];
    I --> M{Data Loaded?};
    J --> M;
    K --> M;
    L --> M{Data Loaded?};
    M -- Yes --> N{Model Specified?};
    M -- No --> S[Log Load Error];
    N -- Yes --> O[Call Gemini API];
    N -- No --> P{Is Text?};
    P -- Yes --> Q[Convert Data to String];
    P -- No --> R[Error: Binary Output];
    O --> T[Format Output];
    Q --> T;
    R --> S;
    G -- Prompt --> U[Call Gemini API];
    U --> T;
    T --> V[Write Output];
    S --> W[End (Error)];
    V --> X[End (Success)];

    subgraph gather_input_units ["gather_input_units"]
        direction LR
        c1[Input String] --> c2{Is URL?};
        c2 -- Yes --> c3[Create Url InputUnit];
        c2 -- No --> c4[process_file_input];
        c4 --> c5{Is PDF & Split?};
        c5 -- Yes --> c6[split_pdf_lopdf(path)];
        c6 --> c7[Create RawData InputUnits (Pages)];
        c5 -- No --> c8[Create File InputUnit];
        c3 --> c9[Collect Units];
        c7 --> c9;
        c8 --> c9;
    end

    subgraph split_pdf_lopdf ["split_pdf_lopdf(path)"]
        direction LR
        s1[Read PDF File] --> s2[Split Pages] --> s3[Create RawData InputUnits];
    end